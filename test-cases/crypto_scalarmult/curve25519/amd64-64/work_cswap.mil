fn crypto_scalarmult_curve25519_amd64_64_work_cswap(reg u64 workp, reg u64 swap){
	 reg u64 t;
	 reg u64 w0;
	 reg u64 w1;
	 reg u64 w10;
	 reg u64 w11;
	 reg u64 w12;
	 reg u64 w13;
	 reg u64 w14;
	 reg u64 w15;
	 reg u64 w2;
	 reg u64 w3;
	 reg u64 w4;
	 reg u64 w5;
	 reg u64 w6;
	 reg u64 w7;
	 reg u64 w8;
	 reg u64 w9;

	//=? swap - 1
	w0 = [workp + 0*8];
	w8 = [workp + 8*8];
	t = w0;
	w0 = w8 if (swap == 1);
	w8 = t if (swap == 1);
	[workp + 0*8] = w0;
	[workp + 8*8] = w8;
	w1 = [workp + 1*8];
	w9 = [workp + 9*8];
	t = w1;
	w1 = w9 if (swap == 1);
	w9 = t if (swap == 1);
	[workp + 1*8] = w1;
	[workp + 9*8] = w9;
	w2 = [workp + 2*8];
	w10 = [workp + 10*8];
	t = w2;
	w2 = w10 if (swap == 1);
	w10 = t if (swap == 1);
	[workp + 2*8] = w2;
	[workp + 10*8] = w10;
	w3 = [workp + 3*8];
	w11 = [workp + 11*8];
	t = w3;
	w3 = w11 if (swap == 1);
	w11 = t if (swap == 1);
	[workp + 3*8] = w3;
	[workp + 11*8] = w11;
	w4 = [workp + 4*8];
	w12 = [workp + 12*8];
	t = w4;
	w4 = w12 if (swap == 1);
	w12 = t if (swap == 1);
	[workp + 4*8] = w4;
	[workp + 12*8] = w12;
	w5 = [workp + 5*8];
	w13 = [workp + 13*8];
	t = w5;
	w5 = w13 if (swap == 1);
	w13 = t if (swap == 1);
	[workp + 5*8] = w5;
	[workp + 13*8] = w13;
	w6 = [workp + 6*8];
	w14 = [workp + 14*8];
	t = w6;
	w6 = w14 if (swap == 1);
	w14 = t if (swap == 1);
	[workp + 6*8] = w6;
	[workp + 14*8] = w14;
	w7 = [workp + 7*8];
	w15 = [workp + 15*8];
	t = w7;
	w7 = w15 if (swap == 1);
	w15 = t if (swap == 1);
	[workp + 7*8] = w7;
	[workp + 15*8] = w15;
	return;
}


