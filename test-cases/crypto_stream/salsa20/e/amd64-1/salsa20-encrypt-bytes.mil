export fn
ECRYPT_encrypt_bytes(reg u64 arg1, reg u8 arg2, reg u8 arg3, reg u64 arg4)
{
    reg u64         A;
    reg u64         B;
    reg u64         C;
    reg u64         D;
    reg u64         E;
    reg u64         R;
    reg u64         S;
    reg u64         T;
    reg u64         U;
    reg u64         V;
    reg u64         a;
    reg u64         b;
    reg u64         bytes;
    stack u64       bytes_backup;
    reg u64         c;
    reg u8          ctarget;
    reg u64         d;
    reg u64         e;
    reg bool        eqf;
    reg u64         i;
    reg u64         in0;
    reg u64         in10;
    reg u64         in12;
    reg u64         in14;
    reg u64         in2;
    reg u64         in4;
    reg u64         in6;
    reg u64         in8;
    stack u64       j0;
    stack u64       j10;
    stack u64       j12;
    stack u64       j14;
    stack u64       j2;
    stack u64       j4;
    stack u64       j6;
    stack u64       j8;
    reg u64         jump;
    reg u8          m;
    stack u8        m_backup;
    reg u8          out;
    reg u64         out0;
    reg u64         out10;
    reg u64         out12;
    reg u64         out14;
    reg u64         out2;
    reg u64         out4;
    reg u64         out6;
    reg u64         out8;
    stack u8        out_backup;
    reg u64         r;
    reg u64         s;
    reg u64         t;
    u8[64] tmp;
    reg u64         u;
    reg u64         v;
    reg u64         x;
    stack u64       x0;
    stack u64       x1;
    stack u64       x10;
    stack u64       x11;
    stack u64       x12;
    stack u64       x13;
    stack u64       x14;
    stack u64       x15;
    stack u64       x2;
    stack u64       x3;
    stack u64       x4;
    stack u64       x5;
    stack u64       x6;
    stack u64       x7;
    stack u64       x8;
    stack u64       x9;
    stack u64       x_backup;

    x = arg1;
    m = arg2;
    out = arg3;
    bytes = arg4;
    // unsigned>? bytes-0
    goto done if (bytes <= 0);
    in0 = [x + 0*8];
    in2 = [x + 1*8];
    in4 = [x + 2*8];
    in6 = [x + 3*8];
    in8 = [x + 4*8];
    in10 = [x + 5*8];
    in12 = [x + 6*8];
    in14 = [x + 7*8];
    j0 = in0;
    j2 = in2;
    j4 = in4;
    j6 = in6;
    j8 = in8;
    j10 = in10;
    j12 = in12;
    j14 = in14;
    x_backup = x;
  bytesatleast1:
    // unsigned<? bytes-64
    goto nocopy if (bytes >= 64);
    ctarget = out;
    out = tmp;
    i = bytes;
    while (i) {
        out[0] = m[0];
        out++;
        m++;
        --i;
    }                           // while (i) { *out++ = *m++; --i }
    out = tmp;
    m = tmp;
  nocopy:
    out_backup = out;
    m_backup = m;
    bytes_backup = bytes;
    in0 = j0;
    in2 = j2;
    in4 = j4;
    in6 = j6;
    in8 = j8;
    in10 = j10;
    in12 = j12;
    in14 = j14;
    x0 = in0;
    x2 = in2;
    x4 = in4;
    x6 = in6;
    x8 = in8;
    x10 = in10;
    x12 = in12;
    x14 = in14;
    in0 >>= 32;
    in2 >>= 32;
    in4 >>= 32;
    in6 >>= 32;
    in8 >>= 32;
    in10 >>= 32;
    in12 >>= 32;
    in14 >>= 32;
    x1 = in0;
    x3 = in2;
    x5 = in4;
    x7 = in6;
    x9 = in8;
    x11 = in10;
    x13 = in12;
    x15 = in14;
    i = 20;
  mainloop:
    a = x12;
    b = x0;
    c = x4;
    e = a + b;
    e <<<=32 7;
    c ^= e;
    x4 = c;
    d = x8;
    e = b + c;
    e <<<=32 9;
    d ^= e;
    x8 = d;
    c += d;
    c <<<=32 13;
    a ^= c;
    x12 = a;
    a += d;
    a <<<=32 18;
    b ^= a;
    x0 = b;
    r = x1;
    s = x5;
    t = x9;
    v = r + s;
    v <<<=32 7;
    t ^= v;
    x9 = t;
    u = x13;
    v = s + t;
    v <<<=32 9;
    u ^= v;
    x13 = u;
    t += u;
    t <<<=32 13;
    r ^= t;
    x1 = r;
    r += u;
    r <<<=32 18;
    s ^= r;
    x5 = s;
    A = x6;
    B = x10;
    C = x14;
    E = A + B;
    E <<<=32 7;
    C ^= E;
    x14 = C;
    D = x2;
    E = B + C;
    E <<<=32 9;
    D ^= E;
    x2 = D;
    C += D;
    C <<<=32 13;
    A ^= C;
    x6 = A;
    A += D;
    A <<<=32 18;
    B ^= A;
    x10 = B;
    R = x11;
    S = x15;
    T = x3;
    V = R + S;
    V <<<=32 7;
    T ^= V;
    x3 = T;
    U = x7;
    V = S + T;
    V <<<=32 9;
    U ^= V;
    x7 = U;
    T += U;
    T <<<=32 13;
    R ^= T;
    x11 = R;
    R += U;
    R <<<=32 18;
    S ^= R;
    x15 = S;
    a = x3;
    b = x0;
    c = x1;
    e = a + b;
    e <<<=32 7;
    c ^= e;
    x1 = c;
    d = x2;
    e = b + c;
    e <<<=32 9;
    d ^= e;
    x2 = d;
    c += d;
    c <<<=32 13;
    a ^= c;
    x3 = a;
    a += d;
    a <<<=32 18;
    b ^= a;
    x0 = b;
    r = x4;
    s = x5;
    t = x6;
    v = r + s;
    v <<<=32 7;
    t ^= v;
    x6 = t;
    u = x7;
    v = s + t;
    v <<<=32 9;
    u ^= v;
    x7 = u;
    t += u;
    t <<<=32 13;
    r ^= t;
    x4 = r;
    r += u;
    r <<<=32 18;
    s ^= r;
    x5 = s;
    A = x9;
    B = x10;
    C = x11;
    E = A + B;
    E <<<=32 7;
    C ^= E;
    x11 = C;
    D = x8;
    E = B + C;
    E <<<=32 9;
    D ^= E;
    x8 = D;
    C += D;
    C <<<=32 13;
    A ^= C;
    x9 = A;
    A += D;
    A <<<=32 18;
    B ^= A;
    x10 = B;
    R = x14;
    S = x15;
    T = x12;
    V = R + S;
    V <<<=32 7;
    T ^= V;
    x12 = T;
    U = x13;
    V = S + T;
    V <<<=32 9;
    U ^= V;
    x13 = U;
    T += U;
    T <<<=32 13;
    R ^= T;
    x14 = R;
    R += U;
    R <<<=32 18;
    S ^= R;
    x15 = S;
    // unsigned>? i-=2;
    goto mainloop if ((i -= 2) > 0);
    out = out_backup;
    m = m_backup;
    in0 = j0;
    out0 = in0;
    out0 >>= 32;
    x86_add_uint32(in0, x0);
    x86_add_uint32(out0, x1);
    out0 <<= 32;
    out0 ^= in0;
    // CHECKME out0 ^= load64_u8(m,0);
    store64_u8(out, 0, out0);   // *(uint64 *) (out + 0) = out0
    in2 = j2;
    out2 = in2;
    out2 >>= 32;
    x86_add_uint32(in2, x2);
    x86_add_uint32(out2, x3);
    out2 <<= 32;
    out2 ^= in2;
    // CHECKME out2 ^= load64_u8(m,8);
    store64_u8(out, 8, out2);   // *(uint64 *) (out + 8) = out2
    in4 = j4;
    out4 = in4;
    out4 >>= 32;
    x86_add_uint32(in4, x4);
    x86_add_uint32(out4, x5);
    out4 <<= 32;
    out4 ^= in4;
    // CHECKME out4 ^= load64_u8(m,16);
    store64_u8(out, 16, out4);  // *(uint64 *) (out + 16) = out4
    in6 = j6;
    out6 = in6;
    out6 >>= 32;
    x86_add_uint32(in6, x6);
    x86_add_uint32(out6, x7);
    out6 <<= 32;
    out6 ^= in6;
    // CHECKME out6 ^= load64_u8(m,24);
    store64_u8(out, 24, out6);  // *(uint64 *) (out + 24) = out6
    in8 = j8;
    out8 = in8;
    out8 >>= 32;
    x86_add_uint32(in8, x8);
    x86_add_uint32(out8, x9);
    out8 <<= 32;
    out8 ^= in8;
    // CHECKME out8 ^= load64_u8(m,32);
    store64_u8(out, 32, out8);  // *(uint64 *) (out + 32) = out8
    in10 = j10;
    out10 = in10;
    out10 >>= 32;
    x86_add_uint32(in10, x10);
    x86_add_uint32(out10, x11);
    out10 <<= 32;
    out10 ^= in10;
    // CHECKME out10 ^= load64_u8(m,40);
    store64_u8(out, 40, out10); // *(uint64 *) (out + 40) = out10
    in12 = j12;
    out12 = in12;
    out12 >>= 32;
    x86_add_uint32(in12, x12);
    x86_add_uint32(out12, x13);
    out12 <<= 32;
    out12 ^= in12;
    // CHECKME out12 ^= load64_u8(m,48);
    store64_u8(out, 48, out12); // *(uint64 *) (out + 48) = out12
    in14 = j14;
    out14 = in14;
    out14 >>= 32;
    x86_add_uint32(in14, x14);
    x86_add_uint32(out14, x15);
    out14 <<= 32;
    out14 ^= in14;
    // CHECKME out14 ^= load64_u8(m,56);
    store64_u8(out, 56, out14); // *(uint64 *) (out + 56) = out14
    bytes = bytes_backup;
    in8 = j8;
    in8 += 1;
    j8 = in8;
    jump = 0;
    // unsigned>? bytes-64
    goto notbytesatleast65 if (bytes <= 64);
    bytes -= 64;
    out += 64;
    m += 64;
    jump = 1;
  notbytesatleast65:
    eqf = (jump == 0);
    goto exitdowhile if (jump == 0);
    goto bytesatleast1;
  exitdowhile:
    // unsigned<? bytes-64
    goto bytesatleast64 if (bytes >= 64);
    m = out;
    out = ctarget;
    i = bytes;
    while (i) {
        out[0] = m[0];
        out++;
        m++;
        --i;
    }                           // while (i) { *out++ = *m++; --i }
  bytesatleast64:
    x = x_backup;
    in8 = j8;
    [x + 4*8] = in8;
  done:
    return;
}
